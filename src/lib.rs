extern crate proc_macro;
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};
use syn::parse::Parse;

#[proc_macro_derive(Entity, attributes(many_to_many, one_to_many))]
pub fn derive_entity(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let struct_name = &input.ident;

    // Look for the fields and attributes
    let fields = if let syn::Data::Struct(data) = &input.data {
        &data.fields
    } else {
        panic!("Only structs are supported for deriving Entity");
    };

    println!("struct_name: {:?}", struct_name);


    // Detect `many_to_many` and `one_to_many` attributes
    let mut many_to_many_relations = vec![];
    let mut one_to_many_relations = vec![];

    for field in fields.iter() {
        for attr in &field.attrs {
            if attr.path().is_ident("many_to_many") {
                let other_entity = extract_related_entity(attr);  // e.g., Filling
                many_to_many_relations.push(other_entity);
            } else if attr.path().is_ident("one_to_many") {
                let other_entity = extract_related_entity(attr);  // e.g., Fruit
                one_to_many_relations.push(other_entity);
            }
        }
    }

    // Generate code for relations
    let relations_code = generate_relations_code(struct_name, many_to_many_relations, one_to_many_relations);

    // Combine all generated code
    let generated = quote! {
        // Generated entity model for this struct
        #[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
        #[sea_orm(table_name = stringify!(#struct_name).to_lowercase())]
        pub struct Model {
            #[sea_orm(primary_key)]
            pub id: i32,
            pub name: String,
        }

        #relations_code
    };

    TokenStream::from(generated)
}

fn extract_related_entity(attr: &syn::Attribute) -> syn::Ident {
    let mut entity_ident = None;

    // Parse the attribute using `parse_nested_meta`
    attr.parse_nested_meta(|meta| {
        // Check if the meta is a path (this is where the entity name comes from)
        if meta.path.is_ident("many_to_many") || meta.path.is_ident("one_to_many") {
            if let Ok(syn::Lit::Str(lit_str)) = meta.value().and_then(syn::Lit::parse) {
                let ident = syn::Ident::new(&lit_str.value(), lit_str.span());
                entity_ident = Some(ident);
            }
        }
        Ok(())
    }).expect("Unable to parse nested meta");

    entity_ident.expect("Unable to extract related entity name from attribute")
}

fn generate_relations_code(struct_name: &syn::Ident, many_to_many_relations: Vec<syn::Ident>, one_to_many_relations: Vec<syn::Ident>) -> proc_macro2::TokenStream {
    let mut code = proc_macro2::TokenStream::new();

    for related_entity in many_to_many_relations {
        // Sort the names lexicographically
        let mut names = vec![struct_name.to_string(), related_entity.to_string()];
        names.sort();

        let table_name = names.join("_").to_lowercase();  // junction table name, e.g., cake_filling

        let junction_struct = quote! {
            // Generated junction struct for many-to-many relation
            #[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
            #[sea_orm(table_name = #table_name)]
            pub struct #table_name {
                #[sea_orm(primary_key)]
                pub id: i32,
                pub #struct_name: i32,
                pub #related_entity: i32,
            }
        };

        let related_impl = quote! {
            impl Related<super::#related_entity::Entity> for Entity {
                fn to() -> RelationDef {
                    Relation::#related_entity.def()
                }

                fn via() -> Option<RelationDef> {
                    Some(super::#table_name::Relation::#struct_name.def().rev())
                }
            }
        };

        code.extend(junction_struct);
        code.extend(related_impl);
    }

    for related_entity in one_to_many_relations {
        let related_impl = quote! {
            impl Related<super::#related_entity::Entity> for Entity {
                fn to() -> RelationDef {
                    Relation::#related_entity.def()
                }
            }
        };

        code.extend(related_impl);
    }

    code
}

#[derive(Entity)]

struct Cake {
    name: String
}

#[test]
fn test_derive_entity_macro() {
    // This struct should expand to the expected code

    // You can now instantiate the struct or invoke methods generated by the macro
    let cake = Cake { name: String::from("Chocolate Cake") };

    // Add any assertions to validate the expanded behavior
    assert_eq!(cake.name, "Chocolate Cake");
}
